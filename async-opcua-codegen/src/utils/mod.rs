use convert_case::{Case, Casing};
use proc_macro2::Span;
use syn::{parse_quote, File, Ident};

mod node_id;
mod qualified_name;
mod render;

pub use node_id::{NodeIdVariant, ParsedNodeId};
pub use qualified_name::split_qualified_name;
pub use render::RenderExpr;

/// Convert the given string to snake_case.
pub fn to_snake_case(v: &str) -> String {
    v.to_case(Case::Snake)
}

/// Create a module file, with `pub mod` and `pub use ...::*` for each module.
pub fn create_module_file(modules: Vec<String>) -> File {
    let mut items = Vec::new();
    for md in modules {
        let ident = Ident::new(&md, Span::call_site());
        items.push(parse_quote! {
            pub mod #ident;
        });
        items.push(parse_quote! {
            pub use #ident::*;
        });
    }

    File {
        shebang: None,
        attrs: Vec::new(),
        items,
    }
}

/// Trait for files generated by code generation.
pub trait GeneratedOutput {
    /// Consume the output and create a syn File object, which is
    /// essentially just a list of top-level rust items.
    fn to_file(self) -> File;

    /// Get the module name for this generated output.
    fn module(&self) -> &str;

    /// Get the file name for this generated output.
    fn name(&self) -> &str;
}

/// Create a rust identifier from the given string, replacing
/// certain invalid characters sometimes found in OPC-UA identifiers.
///
/// This does not do a full validation, just a few basic checks.
pub fn safe_ident(val: &str) -> (Ident, bool) {
    let mut val = val.to_string();
    let mut changed = false;
    if val.starts_with(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'])
        || val == "type"
        || val.contains(['/'])
    {
        val = format!("__{}", val.replace(['/'], "_"));
        changed = true;
    }

    (Ident::new(&val, Span::call_site()), changed)
}
