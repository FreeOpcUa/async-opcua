// This file was autogenerated from schemas/1.05/Opc.Ua.NodeSet2.Services.xml by async-opcua-codegen
//
// DO NOT EDIT THIS FILE

// OPCUA for Rust
// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2017-2024 Adam Lock, Einar Omang
#[allow(unused)]
mod opcua {
    pub use crate as types;
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part3/8.58"] pub struct
    AccessLevelExType : i32 { const CurrentRead = 1i32; const CurrentWrite = 2i32; const
    HistoryRead = 4i32; const HistoryWrite = 8i32; const SemanticChange = 16i32; const
    StatusWrite = 32i32; const TimestampWrite = 64i32; const NonatomicRead = 256i32;
    const NonatomicWrite = 512i32; const WriteFullArrayOnly = 1024i32; const
    NoSubDataTypes = 2048i32; const NonVolatile = 4096i32; const Constant = 8192i32; }
}
impl opcua::types::UaNullable for AccessLevelExType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    AccessLevelExType,
    |v| Ok(AccessLevelExType::from_bits_truncate(v)),
    |v: &AccessLevelExType| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &AccessLevelExType| v.bits().byte_len()
);
impl Default for AccessLevelExType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessLevelExType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AccessLevelExType {
    const TAG: &'static str = "AccessLevelExType";
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part3/8.57"] pub struct
    AccessLevelType : u8 { const CurrentRead = 1u8; const CurrentWrite = 2u8; const
    HistoryRead = 4u8; const HistoryWrite = 8u8; const SemanticChange = 16u8; const
    StatusWrite = 32u8; const TimestampWrite = 64u8; }
}
impl opcua::types::UaNullable for AccessLevelType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    AccessLevelType,
    |v| Ok(AccessLevelType::from_bits_truncate(v)),
    |v: &AccessLevelType| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &AccessLevelType| v.bits().byte_len()
);
impl Default for AccessLevelType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessLevelType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AccessLevelType {
    const TAG: &'static str = "AccessLevelType";
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part5/12.2.9/#12.2.9.13"] pub
    struct AccessRestrictionType : i16 { const SigningRequired = 1i16; const
    EncryptionRequired = 2i16; const SessionRequired = 4i16; const
    ApplyRestrictionsToBrowse = 8i16; }
}
impl opcua::types::UaNullable for AccessRestrictionType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    AccessRestrictionType,
    |v| Ok(AccessRestrictionType::from_bits_truncate(v)),
    |v: &AccessRestrictionType| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &AccessRestrictionType| v.bits().byte_len()
);
impl Default for AccessRestrictionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessRestrictionType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AccessRestrictionType {
    const TAG: &'static str = "AccessRestrictionType";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part14/6.2.11/#6.2.11.2.1
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ActionState {
    #[opcua(default)]
    Idle = 0i32,
    Executing = 1i32,
    Done = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part9/8.3"] pub struct AlarmMask
    : i16 { const Active = 1i16; const Unacknowledged = 2i16; const Unconfirmed = 4i16; }
}
impl opcua::types::UaNullable for AlarmMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    AlarmMask,
    |v| Ok(AlarmMask::from_bits_truncate(v)),
    |v: &AlarmMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &AlarmMask| v.bits().byte_len()
);
impl Default for AlarmMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AlarmMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AlarmMask {
    const TAG: &'static str = "AlarmMask";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part4/7.4
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ApplicationType {
    #[opcua(default)]
    Server = 0i32,
    Client = 1i32,
    ClientAndServer = 2i32,
    DiscoveryServer = 3i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part3/8.60"] pub struct
    AttributeWriteMask : i32 { const AccessLevel = 1i32; const ArrayDimensions = 2i32;
    const BrowseName = 4i32; const ContainsNoLoops = 8i32; const DataType = 16i32; const
    Description = 32i32; const DisplayName = 64i32; const EventNotifier = 128i32; const
    Executable = 256i32; const Historizing = 512i32; const InverseName = 1024i32; const
    IsAbstract = 2048i32; const MinimumSamplingInterval = 4096i32; const NodeClass =
    8192i32; const NodeId = 16384i32; const Symmetric = 32768i32; const UserAccessLevel =
    65536i32; const UserExecutable = 131072i32; const UserWriteMask = 262144i32; const
    ValueRank = 524288i32; const WriteMask = 1048576i32; const ValueForVariableType =
    2097152i32; const DataTypeDefinition = 4194304i32; const RolePermissions =
    8388608i32; const AccessRestrictions = 16777216i32; const AccessLevelEx =
    33554432i32; }
}
impl opcua::types::UaNullable for AttributeWriteMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    AttributeWriteMask,
    |v| Ok(AttributeWriteMask::from_bits_truncate(v)),
    |v: &AttributeWriteMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &AttributeWriteMask| v.bits().byte_len()
);
impl Default for AttributeWriteMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AttributeWriteMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AttributeWriteMask {
    const TAG: &'static str = "AttributeWriteMask";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part8/5.6.7
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum AxisScaleEnumeration {
    #[opcua(default)]
    Linear = 0i32,
    Log = 1i32,
    Ln = 2i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part14/6.4.2/#6.4.2.1
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrokerTransportQualityOfService {
    #[opcua(default)]
    NotSpecified = 0i32,
    BestEffort = 1i32,
    AtLeastOnce = 2i32,
    AtMostOnce = 3i32,
    ExactlyOnce = 4i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part4/7.5
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseDirection {
    #[opcua(default)]
    Forward = 0i32,
    Inverse = 1i32,
    Both = 2i32,
    Invalid = 3i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseResultMask {
    #[opcua(default)]
    None = 0i32,
    ReferenceTypeId = 1i32,
    IsForward = 2i32,
    NodeClass = 4i32,
    BrowseName = 8i32,
    DisplayName = 16i32,
    TypeDefinition = 32i32,
    All = 63i32,
    ReferenceTypeInfo = 3i32,
    TargetInfo = 60i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.9
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ChassisIdSubtype {
    ///Represents a chassis identifier based on the value of entPhysicalAlias object (defined in IETF RFC 2737) for a chassis component (i.e., an entPhysicalClass value of chassis(3))
    ChassisComponent = 1i32,
    ///Represents a chassis identifier based on the value of ifAlias object (defined in IETF RFC 2863) for an interface on the containing chassis.
    InterfaceAlias = 2i32,
    ///Represents a chassis identifier based on the value of entPhysicalAlias object (defined in IETF RFC 2737) for a port or backplane component (i.e., entPhysicalClass has a value of port(10), or backplane(4)), within the containing chassis.
    PortComponent = 3i32,
    ///Represents a chassis identifier based on the value of a unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order) of a port on the containing chassis as defined in IEEE Std 802-2014.
    MacAddress = 4i32,
    ///Represents a chassis identifier based on a network address associated with a particular chassis. The encoded address is actually composed of two fields. The first field is a single octet, representing the IANA AddressFamilyNumbers value for the specific address type, and the second field is the network address value.
    NetworkAddress = 5i32,
    ///Represents a chassis identifier based on the value of ifName object (defined in IETF RFC 2863) for an interface on the containing chassis.
    InterfaceName = 6i32,
    ///Represents a chassis identifier based on a locally defined value.
    Local = 7i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part8/6.6.3
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ConversionLimitEnum {
    #[opcua(default)]
    NoConversion = 0i32,
    Limited = 1i32,
    Unlimited = 2i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part4/7.10
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataChangeTrigger {
    #[opcua(default)]
    Status = 0i32,
    StatusValue = 1i32,
    StatusValueTimestamp = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part14/6.2.4/#6.2.4.2"] pub
    struct DataSetFieldContentMask : i32 { const StatusCode = 1i32; const SourceTimestamp
    = 2i32; const ServerTimestamp = 4i32; const SourcePicoSeconds = 8i32; const
    ServerPicoSeconds = 16i32; const RawData = 32i32; }
}
impl opcua::types::UaNullable for DataSetFieldContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    DataSetFieldContentMask,
    |v| Ok(DataSetFieldContentMask::from_bits_truncate(v)),
    |v: &DataSetFieldContentMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &DataSetFieldContentMask| v.bits().byte_len()
);
impl Default for DataSetFieldContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for DataSetFieldContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for DataSetFieldContentMask {
    const TAG: &'static str = "DataSetFieldContentMask";
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part14/6.2.3/#6.2.3.2.5"] pub
    struct DataSetFieldFlags : i16 { const PromotedField = 1i16; }
}
impl opcua::types::UaNullable for DataSetFieldFlags {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    DataSetFieldFlags,
    |v| Ok(DataSetFieldFlags::from_bits_truncate(v)),
    |v: &DataSetFieldFlags| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &DataSetFieldFlags| v.bits().byte_len()
);
impl Default for DataSetFieldFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for DataSetFieldFlags {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for DataSetFieldFlags {
    const TAG: &'static str = "DataSetFieldFlags";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part14/6.3.1/#6.3.1.1.3
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataSetOrderingType {
    #[opcua(default)]
    Undefined = 0i32,
    AscendingWriterId = 1i32,
    AscendingWriterIdSingle = 2i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DeadbandType {
    #[opcua(default)]
    None = 0i32,
    Absolute = 1i32,
    Percent = 2i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part14/9.1.11/#9.1.11.4
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DiagnosticsLevel {
    #[opcua(default)]
    Basic = 0i32,
    Advanced = 1i32,
    Info = 2i32,
    Log = 3i32,
    Debug = 4i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.1
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum Duplex {
    #[opcua(default)]
    ///Full duplex.
    Full = 0i32,
    ///Half duplex.
    Half = 1i32,
    ///Link is currently disconnected or initializing.
    Unknown = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part3/8.59"] pub struct
    EventNotifierType : u8 { const SubscribeToEvents = 1u8; const HistoryRead = 4u8;
    const HistoryWrite = 8u8; }
}
impl opcua::types::UaNullable for EventNotifierType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    EventNotifierType,
    |v| Ok(EventNotifierType::from_bits_truncate(v)),
    |v: &EventNotifierType| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &EventNotifierType| v.bits().byte_len()
);
impl Default for EventNotifierType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for EventNotifierType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for EventNotifierType {
    const TAG: &'static str = "EventNotifierType";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part11/5.2.2
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ExceptionDeviationFormat {
    #[opcua(default)]
    AbsoluteValue = 0i32,
    PercentOfValue = 1i32,
    PercentOfRange = 2i32,
    PercentOfEURange = 3i32,
    Unknown = 4i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part4/7.7.3
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum FilterOperator {
    #[opcua(default)]
    Equals = 0i32,
    IsNull = 1i32,
    GreaterThan = 2i32,
    LessThan = 3i32,
    GreaterThanOrEqual = 4i32,
    LessThanOrEqual = 5i32,
    Like = 6i32,
    Not = 7i32,
    Between = 8i32,
    InList = 9i32,
    And = 10i32,
    Or = 11i32,
    Cast = 12i32,
    InView = 13i32,
    OfType = 14i32,
    RelatedTo = 15i32,
    BitwiseAnd = 16i32,
    BitwiseOr = 17i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part11/6.7
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum HistoryUpdateType {
    ///Data was inserted.
    Insert = 1i32,
    ///Data was replaced.
    Replace = 2i32,
    ///Data was inserted or replaced.
    Update = 3i32,
    ///Data was deleted.
    Delete = 4i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part18/4.4.4
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdentityCriteriaType {
    ///The rule specifies a UserName from a UserNameIdentityToken.
    UserName = 1i32,
    ///The rule specifies the Thumbprint of a user or CA Certificate.
    Thumbprint = 2i32,
    ///The rule is a Role specified in an Access Token.
    Role = 3i32,
    ///The rule is a user group specified in the Access Token.
    GroupId = 4i32,
    ///The rule specifies Anonymous UserIdentityToken.
    Anonymous = 5i32,
    ///The rule specifies any non Anonymous UserIdentityToken.
    AuthenticatedUser = 6i32,
    ///The rule specifies the combination of an application identity and an Anonymous UserIdentityToken.
    Application = 7i32,
    ///The rule specifies the X509 subject name of a user or CA Certificate.
    X509Subject = 8i32,
    ///The rule specifies any trusted application that has been authenticated with a trusted ApplicationInstance Certificate.
    TrustedApplication = 9i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part5/12.2.5/#12.2.5.1
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdType {
    #[opcua(default)]
    Numeric = 0i32,
    String = 1i32,
    Guid = 2i32,
    Opaque = 3i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.2
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum InterfaceAdminStatus {
    #[opcua(default)]
    ///Ready to pass packets.
    Up = 0i32,
    ///Not ready to pass packets and not in some test mode.
    Down = 1i32,
    ///In some test mode.
    Testing = 2i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.3
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum InterfaceOperStatus {
    #[opcua(default)]
    ///Ready to pass packets.
    Up = 0i32,
    ///The interface does not pass any packets.
    Down = 1i32,
    ///In some test mode. No operational packets can be passed.
    Testing = 2i32,
    ///Status cannot be determined for some reason.
    Unknown = 3i32,
    ///Waiting for some external event.
    Dormant = 4i32,
    ///Some component (typically hardware) is missing.
    NotPresent = 5i32,
    ///Down due to state of lower-layer interface(s).
    LowerLayerDown = 6i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part14/6.3.2/#6.3.2.3.1"] pub
    struct JsonDataSetMessageContentMask : i32 { const DataSetWriterId = 1i32; const
    MetaDataVersion = 2i32; const SequenceNumber = 4i32; const Timestamp = 8i32; const
    Status = 16i32; const MessageType = 32i32; const DataSetWriterName = 64i32; const
    FieldEncoding1 = 128i32; const PublisherId = 256i32; const WriterGroupName = 512i32;
    const MinorVersion = 1024i32; const FieldEncoding2 = 2048i32; }
}
impl opcua::types::UaNullable for JsonDataSetMessageContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    JsonDataSetMessageContentMask,
    |v| Ok(JsonDataSetMessageContentMask::from_bits_truncate(v)),
    |v: &JsonDataSetMessageContentMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &JsonDataSetMessageContentMask| v.bits().byte_len()
);
impl Default for JsonDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for JsonDataSetMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for JsonDataSetMessageContentMask {
    const TAG: &'static str = "JsonDataSetMessageContentMask";
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part14/6.3.2/#6.3.2.1.1"] pub
    struct JsonNetworkMessageContentMask : i32 { const NetworkMessageHeader = 1i32; const
    DataSetMessageHeader = 2i32; const SingleDataSetMessage = 4i32; const PublisherId =
    8i32; const DataSetClassId = 16i32; const ReplyTo = 32i32; const WriterGroupName =
    64i32; }
}
impl opcua::types::UaNullable for JsonNetworkMessageContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    JsonNetworkMessageContentMask,
    |v| Ok(JsonNetworkMessageContentMask::from_bits_truncate(v)),
    |v: &JsonNetworkMessageContentMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &JsonNetworkMessageContentMask| v.bits().byte_len()
);
impl Default for JsonNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for JsonNetworkMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for JsonNetworkMessageContentMask {
    const TAG: &'static str = "JsonNetworkMessageContentMask";
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.3/#5.3.3.1"] pub
    struct LldpSystemCapabilitiesMap : i32 { #[doc =
    "System has capabilities other than those listed below"] const Other = 1i32; #[doc =
    "System has repeater capability"] const Repeater = 2i32; #[doc =
    "System has bridge capability"] const Bridge = 4i32; #[doc =
    "System has WLAN access point capability"] const WlanAccessPoint = 8i32; #[doc =
    "System has router capability"] const Router = 16i32; #[doc =
    "System has telephone capability"] const Telephone = 32i32; #[doc =
    "System has DOCSIS cable device capability (IETF RFC 4639)"] const DocsisCableDevice
    = 64i32; #[doc = "System has only station capability"] const StationOnly = 128i32;
    #[doc = "System has C-VLAN component functionality"] const CvlanComponent = 256i32;
    #[doc = "System has S-VLAN component functionality"] const SvlanComponent = 512i32;
    #[doc = "System has Two-port MAC Relay (TPMR) functionality."] const TwoPortMacRelay
    = 1024i32; }
}
impl opcua::types::UaNullable for LldpSystemCapabilitiesMap {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    LldpSystemCapabilitiesMap,
    |v| Ok(LldpSystemCapabilitiesMap::from_bits_truncate(v)),
    |v: &LldpSystemCapabilitiesMap| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &LldpSystemCapabilitiesMap| v.bits().byte_len()
);
impl Default for LldpSystemCapabilitiesMap {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for LldpSystemCapabilitiesMap {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for LldpSystemCapabilitiesMap {
    const TAG: &'static str = "LldpSystemCapabilitiesMap";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.11
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ManAddrIfSubtype {
    #[opcua(default)]
    ///Optional variable is not set.
    None = 0i32,
    ///Interface is not known.
    Unknown = 1i32,
    ///Interface based on the port-ref MIB object.
    PortRef = 2i32,
    ///Interface based on the system port number.
    SystemPortNumber = 3i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part5/12.3.10
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MessageSecurityMode {
    #[opcua(default)]
    Invalid = 0i32,
    None = 1i32,
    Sign = 2i32,
    SignAndEncrypt = 3i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ModelChangeStructureVerbMask {
    NodeAdded = 1i32,
    NodeDeleted = 2i32,
    ReferenceAdded = 4i32,
    ReferenceDeleted = 8i32,
    DataTypeChanged = 16i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part4/7.23
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MonitoringMode {
    #[opcua(default)]
    Disabled = 0i32,
    Sampling = 1i32,
    Reporting = 2i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NamingRuleType {
    ///The BrowseName must appear in all instances of the type.
    Mandatory = 1i32,
    ///The BrowseName may appear in an instance of the type.
    Optional = 2i32,
    ///The modelling rule defines a constraint and the BrowseName is not used in an instance of the type.
    Constraint = 3i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.4
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NegotiationStatus {
    #[opcua(default)]
    ///The auto-negotiation protocol is running and negotiation is currently in-progress.
    InProgress = 0i32,
    ///The auto-negotiation protocol has completed successfully.
    Complete = 1i32,
    ///The auto-negotiation protocol has failed.
    Failed = 2i32,
    ///The auto-negotiation status is not currently known, this could be because it is still negotiating or the protocol cannot run (e.g., if no medium is present).
    Unknown = 3i32,
    ///No auto-negotiation is executed. The auto-negotiation function is either not supported on this interface or has not been enabled.
    NoNegotiation = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeAttributesMask {
    #[opcua(default)]
    None = 0i32,
    AccessLevel = 1i32,
    ArrayDimensions = 2i32,
    BrowseName = 4i32,
    ContainsNoLoops = 8i32,
    DataType = 16i32,
    Description = 32i32,
    DisplayName = 64i32,
    EventNotifier = 128i32,
    Executable = 256i32,
    Historizing = 512i32,
    InverseName = 1024i32,
    IsAbstract = 2048i32,
    MinimumSamplingInterval = 4096i32,
    NodeClass = 8192i32,
    NodeId = 16384i32,
    Symmetric = 32768i32,
    UserAccessLevel = 65536i32,
    UserExecutable = 131072i32,
    UserWriteMask = 262144i32,
    ValueRank = 524288i32,
    WriteMask = 1048576i32,
    Value = 2097152i32,
    DataTypeDefinition = 4194304i32,
    RolePermissions = 8388608i32,
    AccessRestrictions = 16777216i32,
    All = 33554431i32,
    BaseNode = 26501220i32,
    Object = 26501348i32,
    ObjectType = 26503268i32,
    Variable = 26571383i32,
    VariableType = 28600438i32,
    Method = 26632548i32,
    ReferenceType = 26537060i32,
    View = 26501356i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part5/12.2.5/#12.2.5.2
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeClass {
    #[opcua(default)]
    ///No value is specified.
    Unspecified = 0i32,
    ///The Node is an Object.
    Object = 1i32,
    ///The Node is a Variable.
    Variable = 2i32,
    ///The Node is a Method.
    Method = 4i32,
    ///The Node is an ObjectType.
    ObjectType = 8i32,
    ///The Node is a VariableType.
    VariableType = 16i32,
    ///The Node is a ReferenceType.
    ReferenceType = 32i32,
    ///The Node is a DataType.
    DataType = 64i32,
    ///The Node is a View.
    View = 128i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OpenFileMode {
    Read = 1i32,
    Write = 2i32,
    EraseExisting = 4i32,
    Append = 8i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part14/6.2.10/#6.2.10.2.4
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OverrideValueHandling {
    #[opcua(default)]
    Disabled = 0i32,
    LastUsableValue = 1i32,
    OverrideValue = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part18/5.2.2"] pub struct
    PasswordOptionsMask : i32 { #[doc =
    "Indicates if the server supports the feature to require a password change after the creation of the user."]
    const SupportInitialPasswordChange = 1i32; #[doc =
    "Indicates if the server supports to disable a user."] const SupportDisableUser =
    2i32; #[doc =
    "Indicates if the server supports the configuration NoDelete for a user."] const
    SupportDisableDeleteForUser = 4i32; #[doc =
    "Indicates if the server supports the configuration NoChangeByUser for a user."]
    const SupportNoChangeForUser = 8i32; #[doc =
    "Indicates if the server supports to management of a description for the user."]
    const SupportDescriptionForUser = 16i32; #[doc =
    "Indicates if a upper case ASCII character is required in a password."] const
    RequiresUpperCaseCharacters = 32i32; #[doc =
    "Indicates if a lower case ASCII character is required in a password."] const
    RequiresLowerCaseCharacters = 64i32; #[doc =
    "Indicates if a digit ASCII character is required in a password."] const
    RequiresDigitCharacters = 128i32; #[doc =
    "Indicates if a special character is required in a password."] const
    RequiresSpecialCharacters = 256i32; }
}
impl opcua::types::UaNullable for PasswordOptionsMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    PasswordOptionsMask,
    |v| Ok(PasswordOptionsMask::from_bits_truncate(v)),
    |v: &PasswordOptionsMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &PasswordOptionsMask| v.bits().byte_len()
);
impl Default for PasswordOptionsMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for PasswordOptionsMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for PasswordOptionsMask {
    const TAG: &'static str = "PasswordOptionsMask";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part11/6.8
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PerformUpdateType {
    ///Data was inserted.
    Insert = 1i32,
    ///Data was replaced.
    Replace = 2i32,
    ///Data was inserted or replaced.
    Update = 3i32,
    ///Data was deleted.
    Remove = 4i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part3/8.55"] pub struct
    PermissionType : i32 { const Browse = 1i32; const ReadRolePermissions = 2i32; const
    WriteAttribute = 4i32; const WriteRolePermissions = 8i32; const WriteHistorizing =
    16i32; const Read = 32i32; const Write = 64i32; const ReadHistory = 128i32; const
    InsertHistory = 256i32; const ModifyHistory = 512i32; const DeleteHistory = 1024i32;
    const ReceiveEvents = 2048i32; const Call = 4096i32; const AddReference = 8192i32;
    const RemoveReference = 16384i32; const DeleteNode = 32768i32; const AddNode =
    65536i32; }
}
impl opcua::types::UaNullable for PermissionType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    PermissionType,
    |v| Ok(PermissionType::from_bits_truncate(v)),
    |v: &PermissionType| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &PermissionType| v.bits().byte_len()
);
impl Default for PermissionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for PermissionType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for PermissionType {
    const TAG: &'static str = "PermissionType";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.10
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PortIdSubtype {
    ///Represents a port identifier based on the ifAlias MIB object defined in IETF RFC 2863.
    InterfaceAlias = 1i32,
    ///Represents a port identifier based on the value of entPhysicalAlias (defined in IETF RFC 2737) for a port component (i.e., entPhysicalClass value of port(10) or backplane(4)), within the containing chassis.
    PortComponent = 2i32,
    ///Represents a port identifier based on a unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order) which has been detected by the agent and associated with a particular port (IEEE Std 802-2014).
    MacAddress = 3i32,
    ///Represents a port identifier based on a network address, detected by the agent and associated with a particular port.
    NetworkAddress = 4i32,
    ///Represents a port identifier based on the ifName MIB object, defined in IETF RFC 2863.
    InterfaceName = 5i32,
    ///Represents a port identifier based on the agent-local identifier of the circuit (defined in IETF RFC 3046), detected by the agent and associated with a particular port.
    AgentCircuitId = 6i32,
    ///Represents a port identifier based on a value locally assigned.
    Local = 7i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part14/9.1.3/#9.1.3.7.2"] pub
    struct PubSubConfigurationRefMask : i32 { const ElementAdd = 1i32; const ElementMatch
    = 2i32; const ElementModify = 4i32; const ElementRemove = 8i32; const ReferenceWriter
    = 16i32; const ReferenceReader = 32i32; const ReferenceWriterGroup = 64i32; const
    ReferenceReaderGroup = 128i32; const ReferenceConnection = 256i32; const
    ReferencePubDataset = 512i32; const ReferenceSubDataset = 1024i32; const
    ReferenceSecurityGroup = 2048i32; const ReferencePushTarget = 4096i32; }
}
impl opcua::types::UaNullable for PubSubConfigurationRefMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    PubSubConfigurationRefMask,
    |v| Ok(PubSubConfigurationRefMask::from_bits_truncate(v)),
    |v: &PubSubConfigurationRefMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &PubSubConfigurationRefMask| v.bits().byte_len()
);
impl Default for PubSubConfigurationRefMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for PubSubConfigurationRefMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for PubSubConfigurationRefMask {
    const TAG: &'static str = "PubSubConfigurationRefMask";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part14/9.1.11/#9.1.11.6
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubDiagnosticsCounterClassification {
    #[opcua(default)]
    Information = 0i32,
    Error = 1i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part14/6.2.1
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubState {
    #[opcua(default)]
    Disabled = 0i32,
    Paused = 1i32,
    Operational = 2i32,
    Error = 3i32,
    PreOperational = 4i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part5/12.5
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum RedundancySupport {
    #[opcua(default)]
    None = 0i32,
    Cold = 1i32,
    Warm = 2i32,
    Hot = 3i32,
    Transparent = 4i32,
    HotAndMirrored = 5i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part5/12.44
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum RedundantServerMode {
    #[opcua(default)]
    PrimaryWithBackup = 0i32,
    PrimaryOnly = 1i32,
    BackupReady = 2i32,
    BackupNotReady = 3i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part5/12.3.12
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum SecurityTokenRequestType {
    #[opcua(default)]
    Issue = 0i32,
    Renew = 1i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part5/12.6
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ServerState {
    #[opcua(default)]
    Running = 0i32,
    Failed = 1i32,
    NoConfiguration = 2i32,
    Suspended = 3i32,
    Shutdown = 4i32,
    Test = 5i32,
    CommunicationFault = 6i32,
    Unknown = 7i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part11/6.5.8
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum SortOrderType {
    #[opcua(default)]
    Ascending = 0i32,
    Descending = 1i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part5/12.2.5/#12.2.5.3
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum StructureType {
    #[opcua(default)]
    Structure = 0i32,
    StructureWithOptionalFields = 1i32,
    Union = 2i32,
    StructureWithSubtypedValues = 3i32,
    UnionWithSubtypedValues = 4i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part4/7.40
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TimestampsToReturn {
    #[opcua(default)]
    Source = 0i32,
    Server = 1i32,
    Both = 2i32,
    Neither = 3i32,
    Invalid = 4i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part12/7.8.2/#7.8.2.7
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TrustListMasks {
    #[opcua(default)]
    ///No fields are provided.
    None = 0i32,
    ///The TrustedCertificates are provided.
    TrustedCertificates = 1i32,
    ///The TrustedCrls are provided.
    TrustedCrls = 2i32,
    ///The IssuerCertificates are provided.
    IssuerCertificates = 4i32,
    ///The IssuerCrls are provided.
    IssuerCrls = 8i32,
    ///All fields are provided.
    All = 15i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part12/7.8.2/#7.8.2.8"] pub
    struct TrustListValidationOptions : i32 { #[doc =
    "Ignore errors related to the validity time of the Certificate."] const
    SuppressCertificateExpired = 1i32; #[doc =
    "Ignore mismatches between the host name or ApplicationUri."] const
    SuppressHostNameInvalid = 2i32; #[doc =
    "Ignore errors if the revocation list cannot be found for the issuer of the Certificate."]
    const SuppressRevocationStatusUnknown = 4i32; #[doc =
    "Ignore errors if an issuer has an expired Certificate."] const
    SuppressIssuerCertificateExpired = 8i32; #[doc =
    "Ignore errors if the revocation list cannot be found for any issuer of issuer Certificates."]
    const SuppressIssuerRevocationStatusUnknown = 16i32; #[doc =
    "Check the revocation status online."] const CheckRevocationStatusOnline = 32i32;
    #[doc = "Check the revocation status offline."] const CheckRevocationStatusOffline =
    64i32; }
}
impl opcua::types::UaNullable for TrustListValidationOptions {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    TrustListValidationOptions,
    |v| Ok(TrustListValidationOptions::from_bits_truncate(v)),
    |v: &TrustListValidationOptions| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &TrustListValidationOptions| v.bits().byte_len()
);
impl Default for TrustListValidationOptions {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for TrustListValidationOptions {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for TrustListValidationOptions {
    const TAG: &'static str = "TrustListValidationOptions";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.5
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TsnFailureCode {
    #[opcua(default)]
    ///No failure
    NoFailure = 0i32,
    ///Insufficient bandwidth
    InsufficientBandwidth = 1i32,
    ///Insufficient bridge resources
    InsufficientResources = 2i32,
    ///Insufficient bandwidth for Traffic Class
    InsufficientTrafficClassBandwidth = 3i32,
    ///StreamID in use by another Talker
    StreamIdInUse = 4i32,
    ///Stream destination address already in use
    StreamDestinationAddressInUse = 5i32,
    ///Stream pre-empted by higher rank
    StreamPreemptedByHigherRank = 6i32,
    ///Reported latency has changed
    LatencyHasChanged = 7i32,
    ///Egress port is not AVBCapable
    EgressPortNotAvbCapable = 8i32,
    ///Use a different destination address
    UseDifferentDestinationAddress = 9i32,
    ///Out of MSRP resources
    OutOfMsrpResources = 10i32,
    ///Out of MMRP resources
    OutOfMmrpResources = 11i32,
    ///Cannot store destination address
    CannotStoreDestinationAddress = 12i32,
    ///Requested priority is not an SR Class priority
    PriorityIsNotAnSrcClass = 13i32,
    ///MaxFrameSize is too large for media
    MaxFrameSizeTooLarge = 14i32,
    ///MaxFanInPorts limit has been reached
    MaxFanInPortsLimitReached = 15i32,
    ///Changes in FirstValue for a registered StreamID
    FirstValueChangedForStreamId = 16i32,
    ///VLAN is blocked on this egress port (Registration Forbidden)
    VlanBlockedOnEgress = 17i32,
    ///VLAN tagging is disabled on this egress port (untagged set)
    VlanTaggingDisabledOnEgress = 18i32,
    ///SR class priority mismatch
    SrClassPriorityMismatch = 19i32,
    ///Enhanced feature cannot be propagated to original Port
    FeatureNotPropagated = 20i32,
    ///MaxLatency exceeded
    MaxLatencyExceeded = 21i32,
    ///Nearest Bridge cannot provide network identification for stream transformation
    BridgeDoesNotProvideNetworkId = 22i32,
    ///Stream transformation not supported
    StreamTransformNotSupported = 23i32,
    ///Stream identification type not supported for stream transformation
    StreamIdTypeNotSupported = 24i32,
    ///Enhanced feature cannot be supported without a CNC
    FeatureNotSupported = 25i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.8
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TsnListenerStatus {
    #[opcua(default)]
    ///No Listener detected.
    None = 0i32,
    ///Listener ready (configured).
    Ready = 1i32,
    ///One or more Listeners ready, and one or more Listeners failed.
    PartialFailed = 2i32,
    ///Listener failed.
    Failed = 3i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.6
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TsnStreamState {
    #[opcua(default)]
    ///The related TSN Stream is currently disabled.
    Disabled = 0i32,
    ///The related TSN Stream is in the process of receiving configuration parameters from the TSN Control Layer.
    Configuring = 1i32,
    ///The related TSN Stream has successfully received and applied the configuration from the TSN Control Layer. The related TSN Stream is not fully operational as long as local preconditions (e.g. synchronization state) are not valid.
    Ready = 2i32,
    ///The related TSN Stream object is configured and all other required preconditions (e.g. synchronization state) for sending / receiving data are valid.
    Operational = 3i32,
    ///The related TSN Stream object is in an error state.
    Error = 4i32,
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part22/5.3.1/#5.3.1.7
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TsnTalkerStatus {
    #[opcua(default)]
    ///No Talker detected.
    None = 0i32,
    ///Talker ready (configured).
    Ready = 1i32,
    ///Talker failed.
    Failed = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part14/6.3.1/#6.3.1.3.2"] pub
    struct UadpDataSetMessageContentMask : i32 { const Timestamp = 1i32; const
    PicoSeconds = 2i32; const Status = 4i32; const MajorVersion = 8i32; const
    MinorVersion = 16i32; const SequenceNumber = 32i32; }
}
impl opcua::types::UaNullable for UadpDataSetMessageContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    UadpDataSetMessageContentMask,
    |v| Ok(UadpDataSetMessageContentMask::from_bits_truncate(v)),
    |v: &UadpDataSetMessageContentMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &UadpDataSetMessageContentMask| v.bits().byte_len()
);
impl Default for UadpDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for UadpDataSetMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for UadpDataSetMessageContentMask {
    const TAG: &'static str = "UadpDataSetMessageContentMask";
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part14/6.3.1/#6.3.1.1.4"] pub
    struct UadpNetworkMessageContentMask : i32 { const PublisherId = 1i32; const
    GroupHeader = 2i32; const WriterGroupId = 4i32; const GroupVersion = 8i32; const
    NetworkMessageNumber = 16i32; const SequenceNumber = 32i32; const PayloadHeader =
    64i32; const Timestamp = 128i32; const PicoSeconds = 256i32; const DataSetClassId =
    512i32; const PromotedFields = 1024i32; }
}
impl opcua::types::UaNullable for UadpNetworkMessageContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    UadpNetworkMessageContentMask,
    |v| Ok(UadpNetworkMessageContentMask::from_bits_truncate(v)),
    |v: &UadpNetworkMessageContentMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &UadpNetworkMessageContentMask| v.bits().byte_len()
);
impl Default for UadpNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for UadpNetworkMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for UadpNetworkMessageContentMask {
    const TAG: &'static str = "UadpNetworkMessageContentMask";
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] #[doc =
    "https://reference.opcfoundation.org/v105/Core/docs/Part18/5.2.3"] pub struct
    UserConfigurationMask : i32 { #[doc = "The user cannot be deleted."] const NoDelete =
    1i32; #[doc = "The user is disabled."] const Disabled = 2i32; #[doc =
    "The user cannot change the password."] const NoChangeByUser = 4i32; #[doc =
    "The user must change the password to get the assigned roles. If the password is not changed, the user has only the Role Anonymous."]
    const MustChangePassword = 8i32; }
}
impl opcua::types::UaNullable for UserConfigurationMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
opcua::types::impl_encoded_as!(
    UserConfigurationMask,
    |v| Ok(UserConfigurationMask::from_bits_truncate(v)),
    |v: &UserConfigurationMask| Ok::<_, opcua::types::Error>(v.bits()),
    |v: &UserConfigurationMask| v.bits().byte_len()
);
impl Default for UserConfigurationMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for UserConfigurationMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for UserConfigurationMask {
    const TAG: &'static str = "UserConfigurationMask";
}
#[opcua::types::ua_encodable]
///https://reference.opcfoundation.org/v105/Core/docs/Part4/7.43
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum UserTokenType {
    #[opcua(default)]
    Anonymous = 0i32,
    UserName = 1i32,
    Certificate = 2i32,
    IssuedToken = 3i32,
}
